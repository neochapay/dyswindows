#!/usr/bin/perl

# Y class makefile generator

# This generates the makefile code that will run yclpp

use 5.6.0;
use strict;
use warnings;

use File::Spec;
use IO::File;
use Getopt::Long qw/:config require_order pass_through/;

my $version = "0.1";

sub usage
  {
    print <<END;
yclmakemake -s [OPTION] Makefile.ycl
yclmakemake -c <language> [OPTION] Makefile.ycl

Generates a partial makefile to preprocess Y class definitions

Modes:
 -s, --server
          Generate makefile for server support
 -c <language>, --client <language>
          Generate makefile for client support in the specified language

Options:
 -h, --help
          Show this message
 -Y, --Y-source
          Generated makefile will run within the Y source tree
 -o <dir>, --output <dir>
          Place the output into <dir>
 -v, --verbose
          Be more verbose
END
    exit 0;
  }

my $output;
my $debug;
my $verbose;
my $y_source;
my $server;
my $client;
GetOptions('help|h' => \&usage,
           'output|o=s' => \$output,
           'verbose|v' => \$verbose,
           'Y-source|Y' => \$y_source,
           'server|s' => \$server,
           'client|c=s' => \$client,
          );

usage if 1 != scalar grep {$_} ($server, $client);

my $source_list = shift or die "No source Makefile.ycl given";
die "Too many arguments" if scalar @ARGV;

unless (defined $output)
  {
    $output = $source_list;
    $output =~ s/\.ycl$/.ymk/ or die "Failed to generate output file name";
  }

my (undef, undef, $output_base) = File::Spec->splitpath($output);
my (undef, $dir, undef) = File::Spec->splitpath($source_list);

print "Generating $output using $source_list\n" if $verbose;

print "Reading $source_list...\n" if $verbose;

# First, we read the Makefile.ycl to get the list of sources
my @sources;
{
  my $fh = new IO::File $source_list, "r" or die "Failed to open $source_list: $!";
  while (<$fh>)
    {
      chomp;
      s/^\s+//;
      s/\s+$//;
      next if /^\#/;
      next if $_ eq '';
      push @sources, $_;
    }
}

if ($server)
  {
    # Then we scan the source files, to see what classes are defined in them
    my %class;
    foreach my $source (@sources)
      {
        my $filename = File::Spec->catdir($dir, $source);
        print "Scanning $filename...\n" if $verbose;
        my $fh = new IO::File $filename, "r" or die "Failed to open $filename: $!";

        # Find any class definitions
        while (my $line = <$fh>)
          {
            chomp $line;
            if ($line =~ /^\s*DEFINE_CLASS\(([^\),]+)\)\s*;\s*$/)
              {
                # Found it
                push @{$class{$1}}, $source;
                print "Found definition of $1 in $source\n" if $verbose;
              }
          }
      }

    # Lastly we emit the makefile chunk
    my $fh = new IO::File $output, "w";
    print $fh "# Partial makefile generated by yclmakemake\n";
    print $fh "# This should be included in the real makefile\n";
    print $fh "\n";
    if ($y_source)
      {
        print $fh ".ycl/\%.yc: \%.ycd \$(yclpp) \$(yclpp_lib)/YCL/YCD.pm \$(yclpp_lib)/YCL/Server/C.pm\n";
        print $fh "\t\@test -d .ycl || \$(mkdir_p) .ycl\n";
        print $fh "\tyclpp_libdir=\"\$(yclpp_lib)\" \$(yclpp) -s -o \$\@ \$<\n";
      }
    else
      {
        print $fh ".ycl/\%.yc: \%.ycd \$(yclpp)\n";
        print $fh "\t\@test -d .ycl || \$(mkdir_p) .ycl\n";
        print $fh "\t\$(yclpp) -s -o \$\@ \$<\n";
      }
    print $fh "\n";

    # First the rules to build the class files
    foreach my $class (keys %class)
      {
        if ($y_source)
          {
            print $fh "$class.ycd: \$(yclpp) \$(yclpp_lib)/YCL/YCD.pm "
              . join(' ', map {"\$(srcdir)/$_"} @{$class{$class}}) . "\n";
            print $fh "\tyclpp_libdir=\"\$(yclpp_lib)\" \$(yclpp) -d $class -o \$\@ " . join(' ', map {"\$(srcdir)/$_"} @{$class{$class}}) . "\n";
          }
        else
          {
            print $fh "$class.ycd: \$(yclpp) " . join(' ', map {"\$(srcdir)/$_"} @{$class{$class}}) . "\n";
            print $fh "\t\$(yclpp) -d $class -o \$\@ " . join(' ', map {"\$(srcdir)/$_"} @{$class{$class}}) . "\n";
          }
        print $fh "\n";
      }
    print $fh "\n";

    # Then a variable with all the source files in, so the parent makefile
    # can avoid having to duplicate the list
    print $fh "Y_class_sources = \\\n";
    print $fh join(" \\\n", map {"\t$_"} @sources) . "\n";
    print $fh "\n";

    print $fh "Y_class_defs = \\\n";
    print $fh join(" \\\n", map {"\t$_.ycd"} keys %class) . "\n";
    print $fh "\n";

    print $fh "Y_class_files = \\\n";
    print $fh join(" \\\n", map {"\t.ycl/$_.yc"} keys %class) . "\n";
  }
elsif ($client eq 'c++')
  {
    my $fh = new IO::File $output, "w";
    print $fh "# Partial makefile generated by yclmakemake\n";
    print $fh "# This should be included in the real makefile\n";
    print $fh "\n";
    if ($y_source)
      {
        print $fh ".ycl/\%.cc: \$(ycd_dir)/\%.ycd \$(yclpp) \$(yclpp_lib)/YCL/YCD.pm \$(yclpp_lib)/YCL/Client/Cxx.pm\n";
        print $fh "\t\@test -d .ycl || \$(mkdir_p) .ycl\n";
        print $fh "\tyclpp_libdir=\"\$(yclpp_lib)\" \$(yclpp) -c c++ -o \$\@ \$<\n";
        print $fh "\n";
        print $fh "\$(yh_dir)/\%.yh: \$(ycd_dir)/\%.ycd \$(yclpp) \$(yclpp_lib)/YCL/YCD.pm \$(yclpp_lib)/YCL/Client/Cxxh.pm\n";
        print $fh "\t\@test -d \$(yh_dir) || \$(mkdir_p) \$(yh_dir)\n";
        print $fh "\tyclpp_libdir=\"\$(yclpp_lib)\" \$(yclpp) -c c++h -o \$\@ \$<\n";
      }
    else
      {
        print $fh ".ycl/\%.ycc: \$(ycd_dir)/\%.ycd \$(yclpp)\n";
        print $fh "\t\@test -d .ycl || \$(mkdir_p) .ycl\n";
        print $fh "\t\$(yclpp) -c c++ -o \$\@ \$<\n";
        print $fh "\n";
        print $fh "\$(yh_dir)/\%.yh: \$(ycd_dir)/\%.ycd \$(yclpp)\n";
        print $fh "\t\@test -d \$(yh_dir) || \$(mkdir_p) \$(yh_dir)\n";
        print $fh "\t\$(yclpp) -c c++h -o \$\@ \$<\n";
      }
    print $fh "\n";

    print $fh ".ycl/$_.cc: \$(yh_dir)/$_.yh\n" foreach @sources;
    print $fh "\n";

    print $fh "\$(yh_dir)/$_.yh: \$(ycd_dir)/$_.ycd\n" foreach @sources;
    print $fh "\n";

    print $fh "Y_class_sources = \\\n";
    print $fh join(" \\\n", map {"\t.ycl/$_.cc"} @sources) . "\n";
    print $fh "\n";

    print $fh "Y_class_headers = \\\n";
    print $fh join(" \\\n", map {"\t\$(yh_dir)/$_.yh"} @sources) . "\n";
  }

# arch-tag: a69e32f3-a6e4-4f27-9ec9-24f91abd3e45
